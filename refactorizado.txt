package coe.unosquare.model;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Sinks;
import reactor.core.scheduler.Schedulers;

import java.time.Duration;
import java.util.Comparator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

public class OrderMatcher {

    private static final int SLEEPING_TIME = 100;

    private static final Comparator<Order> buyComparator = Comparator.comparing((Order order) -> -1 * order.price())
            .thenComparing(Order::timestamp);
    private static final Comparator<Order> sellComparator = Comparator.comparing(Order::price)
            .thenComparing(Order::timestamp);

    private final PriorityBlockingQueue<Order> buyOrders = new PriorityBlockingQueue<>(100, buyComparator);
    private final PriorityBlockingQueue<Order> sellOrders = new PriorityBlockingQueue<>(100, sellComparator);

    private final ConcurrentHashMap<Order, Order> buyOrdersProcessed = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<Order, Order> sellOrdersProcessed = new ConcurrentHashMap<>();

    private final AtomicInteger buyRequests = new AtomicInteger(0);
    private final AtomicInteger sellRequests = new AtomicInteger(0);
    private final AtomicInteger buyProcessed = new AtomicInteger(0);
    private final AtomicInteger sellProcessed = new AtomicInteger(0);
    private final AtomicInteger buyCompleted = new AtomicInteger(0);
    private final AtomicInteger sellCompleted = new AtomicInteger(0);

    private final Sinks.Many<Order> buyOrderSink = Sinks.many().multicast().onBackpressureBuffer();
    private final Sinks.Many<Order> sellOrderSink = Sinks.many().multicast().onBackpressureBuffer();

    public OrderMatcher() {
        // Procesa las órdenes periódicamente
        Flux.interval(Duration.ofMillis(SLEEPING_TIME))
                .flatMap(tick -> processOrders())
                .subscribeOn(Schedulers.boundedElastic())
                .subscribe();
    }

    // Agregar orden de manera reactiva
    public Mono<Void> addOrder(Order order) {
        if (order.orderType() == OrderType.BUY) {
            return Mono.fromRunnable(() -> {
                buyOrders.add(order);
                buyOrderSink.tryEmitNext(order);  // Emitir la nueva orden de compra
            });
        } else {
            return Mono.fromRunnable(() -> {
                sellOrders.add(order);
                sellOrderSink.tryEmitNext(order);  // Emitir la nueva orden de venta
            });
        }
    }

    // Procesar las órdenes coincidentes
    private Mono<Void> processOrders() {
        return Mono.fromRunnable(() -> {
            while (!buyOrders.isEmpty() && !sellOrders.isEmpty()
                    && buyOrders.peek().price() >= sellOrders.peek().price()) {
                Order bo = buyOrders.poll();
                Order so = sellOrders.poll();
                
                buyOrdersProcessed.putIfAbsent(bo, so);
                sellOrdersProcessed.putIfAbsent(so, bo);

                buyProcessed.incrementAndGet();
                sellProcessed.incrementAndGet();
            }
        });
    }

    // Verifica si una orden ha sido procesada y devuelve el par correspondiente
    public Mono<Order> matchOrder(Order currentOrder) {
        if (currentOrder.orderType() == OrderType.BUY) {
            buyRequests.incrementAndGet();
            return Mono.justOrEmpty(buyOrdersProcessed.remove(currentOrder))
                    .doOnSuccess(order -> buyCompleted.incrementAndGet());
        } else {
            sellRequests.incrementAndGet();
            return Mono.justOrEmpty(sellOrdersProcessed.remove(currentOrder))
                    .doOnSuccess(order -> sellCompleted.incrementAndGet());
        }
    }

    // Devuelve el estado actual de todas las órdenes
    public Mono<ApiResponse> getAllOrders() {
        return Mono.just(new ApiResponse(true, "All orders in process",
                new AvailableOrdersOrdersInProcess(
                        buyOrders.stream().toList(),
                        sellOrders.stream().toList()
                )));
    }

    // Devuelve las estadísticas de las órdenes procesadas
    public Mono<OrderStats> getStatistics() {
        return Mono.just(new OrderStats(
                buyRequests.get(), sellRequests.get(),
                buyProcessed.get(), sellProcessed.get(),
                buyCompleted.get(), sellCompleted.get()
        ));
    }
}
